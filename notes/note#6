11월 13일

재정의함수 vs 가상함수(오버라이딩)
가상함수 : virtual로 선언된 멤버 함수

함수 재정의 redefine
오버라이딩 overriding

베이스클래스에 virtul로 선언해도, 실제 실행하면 파생클래스에 있는 함수가 실행된다. -> 동적 바인딩
코드의 재사용, 간결, 모듈, 등등 올라감

class Base {
public :
  {virtual} void f() {	std::cout << "base" << std::endl;	}};

class Derived : public Base {
public:	
  {virtual} void f() {  std::cout << "Derived" << std::endl;  }};

int main() {
	Derived derived, *pDerived; // Dervived의 객체와, 객체의 주소 변수 생성
	pDerived = &derived;        // 둘을 짝짝꿍 시켜줌
  pDerived->f();              // Derived 호출 잘 됨(걍 테스트임)

	Base *pBase;                // Base타입의 포인터 변수 생성 
	pBase = pDerived;           // derived가 Base타입으로 업캐스팅 됨
	pBase->f();                 // 이제 호출을 해보면????
                             결론 {virtual}가 있다면(오버라이딩) Derived가 출력되고,
                                             없다면(함수 재정의) base가 출력된다.
	
	return 0;
}

오버라이딩시 일치해야 하는 3가지
  -  가상 함수 이름
  -  매개 변수 타입과 갯수 //이게 다르면 오버로딩임
  -  리턴 타입

객체지향 구조에서 자주 쓰이는 3가지 비교해보자
1. 오버로딩 - 매개 변수 타입, 개수가 다르지만, 이름이 같은 함수들이 중복 작성됨
존재 : 클래스의 멤버들 사이, 외부 함수들 사이, 기본 클래스-파생 클래스 사이
목적 : 이름이 같은 여러 개의 함수를 중복 작성하여 사용의 편의성 향상
바인딩 : 정적 바인딩, 컴파일 시 중복된 함수들의 호출 구분
객체지향 특성 : 컴파일 시간 다형성

2. 함수 재정의 - 기본 클래스의 함수를 파생 클래스에서 이름,매개변수 타입+갯수,리턴 타입까지 똑같은 원형으로 재작성
존재 : 상속 관계
목적 : 기본 클래스의 멤버 함수와 별도로 파생 클래스에서 필요하여 재작성
바인딩 : 정적 바인딩, 컴파일 시 함수의 호출 구분
객체 지향 특성 : 컴파일 시간 다형성

3. 오버라이딩 - 기본 클래스의 가상 함수를 파생 클래스에서 이름, 매개변수 타입+갯수, 리턴 타입까지 똑같은 원형으로 재작성
존재 : 상속 관계
목적 : 기본 클래스에 구현된 가상 함수를 무시하고, 파생 클래스에서 새로운 기능으로 재작성하고자함
바인딩 : 동적 바인딩, 실행 시간에 오버라이딩된 함수를 찾아 실행
객체 지향 특성 : 실행 시간 다형성

