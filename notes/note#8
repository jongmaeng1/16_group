11월 27일 - 입출력 시스템

스트림이란?
  -  데이터의 흐름, 혹은 데이터를 전송하는 소프트웨어 모듈
      * 흐르는 시내와 유사한 개념
  -  스트림의 양 끝에는 프로그램과 장치 연결
      * 보낸 순서대로 데이터 전달
      * 입출력 기본 단위 : 바이트

키 입력 스트림 버퍼
  -  입력장치로부터 입력된 데이터를 프로그램으로 전달하기 전에 일시 저장
  -  키 입력 도중 수정 가능(Backspace로 버퍼 지움)
  -  C++응용프로그램은 사용자의 키 입력이 끝난 시점에서 읽음
  -  <Enter>키가 입력의 끝을 의미하고, 그 시점부터 입력 버퍼에서 읽기 시작

스크린 출력 스트림 버퍼
  -  프로그램에서 출력된 데이터를 출력 장치로 보내기 전에 일시 저장
  -  출력 장치를 반복적으로 사용하는 비효율성 개선
  -  버퍼가 꽉 차거나, 강제 출력 명령 시 출력 장치에 출력

입출력 방식 2가지
  1. 스트림 입출력 방식 stream I/O (C++표준은 이 방식만 지원, 높은 호환성)
    -  스트림 버퍼를 이용한 입출력 방식
    -  입력된 키는 버퍼에 저장
    -  출력되는 데이터는 일차적으로 스트림 버퍼에 저장

  2. 저 수준 입출력 방식 raw lever console I/O (C++프로그램의 호환성 낮음)
    -  키가 입력되는 즉시 프로그램에게 키 값 전달
    -  <Backspace>키 자체도 바로 전달됨
    -  게임 등 키 입력이 즉각적으로 필요한 곳에 사용
    -  프로그램이 출력하는 즉시 출력 장치에 출력
    -  컴파일러마다 다른 라이브러리나 API지원

대표적인 구 표준(C++ 03) 입출력 라이브러리 클래스
ios, istream, ostream, iostream, ifstream, ofstream, fstream
문자를 한 바이트의 char로 처리하기에, cin으로 한글을 읽을 수 없음 영어+기호(1byte), 한글(2byte)

이런 문제를 해결하기 위해 입출력 라이브러리가 템플릿으로 작성됨

using iostream = basic_iostream<char, char_traits<char>>
유징 지시어로 basic iostream<>템플릿에 iostream이라는 별칭을 붙임

입출력 클래스

ios : 모든 입출력 스트림 클래스들의 Base클래스, 스트림 입출력에 필요한 공통 함수와 상수, 멤버 변수 선언

istream : 문자 단위 입력 스트림
ostream : 문자 단위 출력 스트림
iotream : 문자 단위로 입출력을 동시에 할 수 있는 스트림

ifstream(읽기), ofstream(쓰기), fstream(둘 다)
파일에서 읽고 쓰는 기는을 가진 파일 입출력 스트림

ostream 멤버 함수
ostream& put(char ch)            char 하나 스트림에 출력
ostream& write(char* str, int n) str 배열에서 n개의 문자 출력   
ostream& flush()                 스트림 버퍼에 있는 내용 출력

cout.put('H'); 
cout.put('i');   혹은  cout.put('H').put('i'); 해도 된다
-------------------------------------------------------------------
int ch;  [int로 받기]
while ((ch = cin.get()) != EOF) { //입력받고, 파일의 끝인지도 확인해줌
		cout.put(ch);
		if(ch == '\n') // <Enter>키가 입력되면 읽기 중단
			break;         
	}
-------------------------------------------------------------------
char ch;  [char로 받기]
	while (true) {
		cin.get(ch);
		if (cin.eof()) break; // EOF만나면 종료
		cout.put(ch);
		if (ch == '\n') break; //<Enter> 눌리면 종료
	}
------------------------------------------------------------------------------------
char str[10];
cin.get(str, 10); //최대 9개의 문자를 읽고 끝에 '\0'을 붙여 str배열에 저장
get()도중 <Enter>키 '\n'를 만날 때 읽기를 중단하고 리턴함.
'\n'은 스트림 버퍼에 남아있음 -> 이후 get()으로 읽기를 시도하면 남은 '\n'키를 만나서 바로 리턴하여 무한루프에 빠질 수 있음
이 문제 때문에 cin.get()이나 cin.ignore(1);를 통해 남아있던 '\n'를 읽어버려야 함
			↓ 예시
while (true) {
		cout << "종료하려면 exit를 입력하세요 >> ";
		cin.get(cmd, 80); //79개의 영어까지 읽음
		if (strcmp(cmd, "exit") == 0) {
			cout << "프로그램 종료합니다.";
			return 0;
		}
		else {
			cin.ignore(1);
		}
	}
------------------------------------------------------------------------------------
포맷 입출력 방법 3가지 (printf와 비슷한거)
	1. 포맷 플래그 : 입출력 스트림에서 입출력 형싱을 지정하기 위한 플래그
	2. 포맷 함수 : width, fill, precision
	3. 조작자(함수) : manipulator, 스트림 조작자
		- C++ 표준 라이브러리에 구현됨
		- 개발자만의 조작자 작성 가능함
		- 매개 변수 유무로 구분됨
		- <<, >> 연산자와 함께 사용됨
	* 매개 변수 없는 조작자
	cout << hex << showbase << 30 << endl; // 0x1e 출력
	cout << dec << showpos << 100 << endl; // +100 출력

	* 매개 변수 있는 조작자 - #include<iomanip> 필요함
	cout << setw(10) << setfill('^') << "Hello" << endl; // ^^^^^Hello 출력
------------------------------------------------------------------------------------
			삽입 연산자(<<)
	- insertion operator, 삽입자라고도 부름
	- ostream 클래스에 중복 작성되어 있음

Point 클래스(int x, y 존재함)를 바로 출력할 수 있는 << 연산자 만들기
ostream& operator << (ostream& stream, Point a) {
	stream << "(" << a.x << "," << a.y << ")";
	return stream;
}
물론 이 함수가 x, y필드에 접근할 수 있게 클래스에서 friend 해줘야함~
------------------------------------------------------------------------------------
			추출 연산자(>>)
	- extraction operator, 추출자라고도 부름
	- istream클래스에 중복 작성되어 있음
Point 클래스(int x, y 존재함)를 바로 입력할 수 있는 >> 연산자 만들기
istream& operator >> (istream& stream, Point& a) {
	cout << "x 좌표 >>";
	stream >> a.x;
	cout << "y 좌표 >>";
	stream >> a.y;
	return stream;
}
물론 이것도 당연히 friend 해줘야함~
------------------------------------------------------------------------------------
매개 변수가 없는 조작자
istream& manipuLatorFunction (isteram& ins)
ostream& manipuLatorFunction (ostream& outs)
아웃스트림의 경우
ostream& fivestar(ostream& outs) {
	return outs << "*****";
}
이렇게 선언해놓으면
cout << fivestar; // 출력결과 ***** 가 나온다~

인스트림의 경우
istream& question(istream& ins) {
	cout << "거울아 거울아 누가 제일 예쁘니?";
	return ins;
}
이렇게 선언해놓으면
cin >> question >> answer;
하면 누가 이쁘냐고 물어보고, answer에 저장한다~
------------------------------------------------------------------------------------
				느낀점
조작자의 동작방식이 좀 웃기다. 이번 수업을 통해 처음 알게 된 것인지라
어떤 아키텍트를 갖고 동작할까 궁금했는데 공식적으로 존재하기보단
그냥 기존의 연산자 중복선언을 통해 개발자들이 나름대로 잔머리 굴려서 편하게 쓴 거고,
그 방법을 '조작자'라고 이름 지은 느낌이다. 이걸 C++의 기능이라고 할 수 있을까 궁금하다.

근데 뭐 따지고 보면 이런 식으로 별도의 기능을 제공하는 건 아니고
basic한 문법을 통해 구현된 것들이 한둘이 아닌 것 같다.
