세상 모든 것이 캡슐화 되어있는 객체이다.
어쩌면 말장난이지 않을까?? 인간이라는 객체는 장기라는 속성을 캡슐화하고 있고, 장기는 세포를 캡슐화하고 있고, 
세포는 미토콘드리아같은 세포구성물질을 캡슐화 할테고… 계속 하다 가장 작은 전자 수준의 단위까지 갔을 때 그것을 객체라고 할 수 있을까?
단지 물질을 구성하는 원소를 계층적인 시각으로 바라보는 것을 ‘객체’라고 부르는 느낌이다. 그렇다면 “세상 모든 것이 객체이다”가 아니고 
“세상 모든 것이 계층적이다”라고 하는 게 더 부합하지않나??하는 궁금증이 있다.

클래스와 객체
붕어빵틀과 붕어빵의 관계, 설계도와 제품의 관계.. 그렇다면 클래스는 소스파일이고, 객체는 메모리영역을 얘기하는건가?
그런데 클래스(소스파일)도 실행을 위해 메모리에 올려야하는데, 그렇다면 그 경계를 정확히 어떻게 나눌 수 있는가

선언과 호출 실습 (donut, pizza 면적 구하기)
-	Public이 접근지정자인 건 알겠는데, 다른 접근지정자로 선언시 구현방법이 어떻게 달라질지를 모르겠다. = 접근지정자 이해도 낮음
-	Circle()클래스를 만들고 getArea()메소드를 ::를 통해서 네임스페이스 포함시키는 것 같은데, 이해는 했지만 누군가에게 설명해보라하면 좀 버벅일 것 같다
-	Donut객체를 만들 때 double area 로 만들었지만 pizza객체를 만들 때엔 double이 없는 area만을 사용하였다. 둘이 왜 다른가? 
-> 현재는 파트너의 설명으로 area메모리를 하나만 만들어서 쓰고, donut이 끝났으니까 pizza를 처리하기 위해 덮어쓰려는 목적이었단 걸 이해하였음! 

이에 대한 응용 (Rectangle로 사각형 면적 구하기)
-	같은 프로젝트에 소스파일을 만들어서 살짝 혼란스러웠음 = 이는 C++이슈가 아닌, 비주얼 스튜디오 숙련도 이슈….
-	위에 언급된 선언과 호출의 부족함 부분이 대부분 동일함… 집에서 복습 하기로 약속했음

위임생성자
생성자 자체를 잘 모르겠는데, 위임생성자를 배울라니까 좀 힘들다. 그래도 파트너랑 같이 생성자에 대해 얘기를 나눠보니 개념적으로는 이해했다. 

생성자를 하나라도 선언하지 않는다면 기본생성자를 만드는데, 매개변수가 존재하는 생성자가 있을 경우라면 과연 기본 생성자를 컴파일러가 자동으로 만들어줄까??
인철 - 근거는 부족하지만 그럴 것 같다! 자동으로 만들어주는 기능까지 고려해서 제작된 기능인데, 매개변수를 입력 받는 생성자가 존재한다는 이유로 기본생성자를 만들어 주지않을 정도로 시스템이 대충 짜여져있을 것 같지 않다!
종명 – 불가능할 것 같다! 이미 생성자가 있으니까 기본생성자가 안 만들어질 것 같다.
정답은 종명!!!!

생성자 실습 (rect1, rect2, rect3을 만들어서 정사각형인지 체크하기)
-	클래스를 선언하는 데 이제 은근 숙련이 되었다
-	기본생성자를 만드는데는 아무 문제가 없다. 그런데 매개변수가 포함된 생성자를 만들 때 입력받은 매개변수를 필드값을 넣는데 살짝 어려웠다. 이 또한 한 번만 복습하면 해결될 것 같다.
-	isSquare()함수를 어떻게 구현하는지 한 번에 생각나지 않았다. 일단 각 가로, 세로를 불러와서 둘이 같은지를 비교하교, ture라면 true를 리턴하고, false라면 false를 리턴했다.
-	Rect2의 생성자를 구현할 때 width = height = length로 만드는 걸 보니까 기본생성자랑 너무 비슷하다, 이것을 효율적으로 하나로 만들 순 없을까? 라는 궁금증도 있었다.
 
소멸자 순서
-	1. 지역객체는 해당 영역이 종료되면 소멸되고, 전역객체는 프로그램이 끝나야 소멸
-	2. 역순으로 사라진다
이 두가지 조건을 만족하는 것은 아래와 같이 대화를 나누어봤는데, 정답이라서 뿌듯하다

Inline 인라인 키워드
-	함수 호출에 따른 오버헤드가 존재하지 않음
-	함수를 그대로 대체해서 컴파일 시킴
-	장단점이 명확해서 상황에 맞게 사용해야함
