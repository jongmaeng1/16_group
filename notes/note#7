11월 20일

함수의 파라미터 타입만 다르고
구현부분이 완전히 똑같다면? -> 탬플릿하자!

   tmeplate<class T> 
{템플릿 키워드} < {제네릭 타입 키워드} {제네릭 타입} >

template <class T> 
void myswap(T & a, T & b)
  T tmp;
  tmp = a;
  a = b;
  b = tmp

    ↑ 의 경우를 보면 T부분에 int, double, char 다 들어갈 수 있다.
      이 모둔 경우의 수를 하나의 제네릭 변수로 일반화 한 것

단 {함수}(T, T)해놓고 첫 번재는 int, 두 번째는 char로 호출하면 컴파일 오류가 난다.
 -> 하나의 T로 두 개의 타입으로 구체화할 수 없기 때문 -> 구체화 오류

[올바른 예시]
#include <iostream> 
using namespace std;
template <class T> 
T bigger(T a, T b) { // 두 개의 매개 변수를 비교하여 큰 값을 리턴 
  if(a > b) 
    return a; 
  else
    return b; }

int main() {
int a=20, b=50; 
char c='a', d='z'; 
cout << "bigger(20, 50)의 결과는 " << bigger(a, b) << endl; 
cout << "bigger('a', 'z')의 결과는 " << bigger(c, d) << endl;
}

템플릿 함수와 중복 함수 중 중복함수가 우선적으로 바인딩됨

제네릭 클래스는 제네릭 함수처럼 template<class T>를 선언 후 모든 타입을 T로 대체하면 된다

[cout함수가 어떻게 파라미터를 쓰는가]
cout << a << b << c ;
스택 프레임을 만들어서 c, b, a순서로 집어넣고 a, b, c순서로 출력시킨다.
따라서 파라미터가 어떠한 자료의 pop()인 경우 뒤에서 먼저 작동하기 때문에 유의해야함!

STL(Standard Template Library 표준 템플릿 라이브러리) 구성요소 3가지
  -  컨테이너 : 템플릿 클래스
  -  iterator : 컨테이너 원소에 대한 포인터
  -  알고리즘 : 템플릿 함수

컨테이너 : 데이터를 담아두는 자료 구조를 표현한 클래스임
          ex) 리스트, 큐 , 스택, 맵, 셋, 벡터

iterator : 컨테이너의 원소들을 순회하면서 접근하기 위해 만들어진 컨테이너 원소에 대한 포인터

알고리즘 : 컨테이너 원소에 대한 복사, 검색, 삭제, 정렬 등의 기능을 구현한 템플릿 함수
          컨테이너의 멤버 함수 아님

----------------------------------------------------------------
               vector 기본사용

vector<int> v;  로 생성한다.

v.push_back(1);
v.push_back(2);   차례대로 1, 2, 3 삽입
v.push_back(3);

int s = v.size();  리턴값 3
int c = v.capacity();  리턴값 7

v.at(2) = 5;       at는 인덱스로 생각하면 됨 3이 5가됨
int n = v.at(1);    리턴값 1번째 값인 2임
-----------------------------------------------------------------
               iterator 활용

vector<int>::iterator it;   반복자 변수 생성

it = v.begin();             시작 주소로 초기화
it = v.end();               끝 주소로 초기화

it++;                       인덱스 증가

int n = *it;                원소 읽기

n = n*2;                    원소 쓰기
*it = n;

it = v.erase(it);           동작 : 원소삭제
                            리턴 : 다음 원소의 주소
--------------------------------------------------------------------
                     map
Map<string, string> dic;                string에 대응하는 string 맵 생성

dic.insert(make_pair("love", "사랑"))    ("love","사랑")pair를 dic에 추가

dic["love"] = "사랑";                     "love"에 대응하는 값을 "사랑"으로 설정

string kor = dic["love"]                  kor = "love"에 대응하는 값을 리턴(없으면 만듦)
string kor = dic.at("love")               kor = "love"에 대응하는 값을 리턴(없으면 에러) 
---------------------------------------------------------------------
느낀점
1. 제네릭 키워드를 자바에서 자주 봤었는데, cpp에서 보니까 은근 반가웠다.
수업 중에 생긴 궁금증은 Map으로 선언된 dic이 존재할 때 dic["a"]와 dic.ac("a")의 차이가 궁금했는데
검색해보니 dic[]은 없으면 새롭게 만드는 것이고, at()은 없으면 에러가 난다는 것이다.
그런데 여전한 궁금증은 "어째서 다를까"이다. 함수의 input/output만 아는 것 외에
어떤 구조로 동작하는지를 정확하게 알고있다면 왜 dic[]방식은 새로 만들고, at()은 에러를 뱉는지 알 수 있을 것 같으니
나중에 자세하게 알아보아야겠다.

2. 제네릭 변수의 런타임 동작방식이 궁금하다
컴파일단계과 런타임시 메모리에 쓰이는 low lever적인 동작방식을 정확히 알고싶다.
이것도 앞선 1번의 궁금증과 같이 따로 알아보아야겠다.
