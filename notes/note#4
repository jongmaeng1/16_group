10월 30일  이종명, 정인철

프렌드 함수란 마치 친구처럼 외부의 존재이면서 나의 집에서 가족과 대등한 권한을 갖는 키워드이다.

인철의 궁금한 점 : 이런 거 써서 편하게 접근할거면 객체지향의 캡슐화 정신에 위배되는 거 아닌가?

프렌드 자세히!
존재 : 클래스 외부에 작성된 함수. 멤버가 아님
자격 : 클래스의 멤버 자격 부여. 클래스의 모든 맴버에 대해 접근 가능
선언 : 클래스 내에 freiend키워드로 선언
개수 : 프렌드 함수 개수에 제한 없음

class A {
 ~~~~
 }

class B {
  ~~~~
  friend bool methodA();
}
해놓으면 methodA가 실행할 때 B의 private한 메서드와 필드에 접근할 수 있다!

연산자는 모두 정의가 되어있고, 필요에 의해서 오버로딩하여 객체에 대한 복잡한 처리를 간단하게 해결할 수 있다.

{리턴타입} operator{연산자}({매개변수리스트});
로 생성하며 

Color a(BLUE), b(RED), c;
가 있을 때
1. 클래스의 멤버 함수
class Color {
  ~~~
  Color operator+ (Color op2);
  bool operator== (Color op2);
};


2. 외부 함수로 구현되고 프렌드로 선언
Color operator + (Color op1, Color p[2); //외부함수
Color operator == (Color op1, Color p[2); //외부함수
class Color {
 ~~~
 friend Color operator+ (Color op2);
 friend bool operator== (Color op2);
};

a == b  (컴파일러)  a.==(b)
인철 : 이런식으로 돌아가는지 모르고 있었다. 
이걸 몰랐다는 게 부끄럽기도 하고 지금까지 대부분의 프로그래밍 수업에서 얼마나 대충 배웠는지 알 것 같다.
가장 충격이었던 것은 후위연산자의 동작방식이다.

printf("%d", a++) 를 처리할 때 그냥... 값을 먼저 넘겨주고 더하기 연산을 한다고 알고있었다.
그렇게 배웠었고, 한 번도 의구심을 가져본 적 없었다. 
생각해보면 방금 언급한 "먼저 넘겨주고 더하기 연산"은 불가능하다.
모든 함수는 return을 하면 종료되기 때문이다

호출되면 객체의 상태를 복사해놓고, 객체를 증가시킨 뒤 복사했던 값을 리턴하는 방식이었다.
최인엽교수님과 진행하는 객체지향 수업에 대해 아주 높은 만족도를 느끼고 있다.
그 이유는 이와 같이 내가 알고있다고 믿고 있었던 로직이었지만 실제로 보니 전혀 모르는 것들이 많았기 때문이다.

