11월 6일

상속이란
공통된 사항은 부모에 놓고, 파생에서 가져다가 쓰는 방식으로, 효율적으로 코딩할 수 있다.(사용성이 높다)
클래스의 개념, 객체한테는 없는거임!

장점 : 
 - 간결한 클래스 작성
 - 클래스 간의 계층적 분류 및 관리 용이함
 - 클래스 재사용과 확장을 통해 생산성 향상

다중상속 : 2개 이상의 클래스로부터 상속 받는 것!

하이라키라는 말을 처음 들어봤다!
계층적 구조를 얘기한다.

업 캐스팅
자식클래스 포인터가 부모 클래스 포인터에 치환되는 것
ChiledClass A;
ChiledClass *Ap = &A;
BaseClass *pBase = Ap;
이렇게 하면 
A의 주소를 갖고있는 ChiledClass포인터 변수와 BaseClass포인터 변수가 생긴다.

다운 캐스팅
기본(부모) 클래스의 포인터가 파생 클래스의 포인터에 치환되는 것
ChiledClass A;
ChiledClass *Ap;
BaseClass *pBase = &Ap; 

pBase->showPoint(); //여기까지는 업케스팅

Ap = (ChiledClass *)pBase; // 타입을 ChiledClass로 강제변환하는 다운 캐스팅
Ap는 이제 ChiledClass형태의 포인터변수이다.

상속 받을 때 접근 지정자에 대해서는 기존의 알고있는 접근지정자 개념과 크게 다르지 않아서 쉽게 이해할 수 있었다.
그러나 재밌었던 것은 상속받은 클래스의 생성자와 소멸자이다.
[수업자료에 있던 질문] 
Q : 파생 클래스의 객체가 생성될 때 파생 클래스의 생성자와 기본 클래스의 생성자가 모드 실행되는가?
A : 둘 다 실행된다.

Q : 파생 클래스의 생성자와 기본 클래스의 생성자 중 어떤 생성자가 먼저 실행되는가?
A : 기본 클래스의 생성자가 먼저 실행된 후 파생 클래스의 생성자가 실행된다.

다중 상속의 문제점으로는 기본 클래스 멤버가 중복될 수 있다
아래와 같은 상속 하이라키가 있다고 가정해보자
      A
     / \
   AB   AC 
     \ /
     ABC
그렇다면 ABC클래스에는 A의 멤버가 두 번이나 선언된다는 것이다.
이를 해결하기 위해 virtual키워드가 존재하는데, virtual로 상속받은 클래스는 객체가 생성될 때 해당 클래스를 한 번만 실행하는 방법으로 문제를 해결한다.


[ 수업 이후 해결되지 않은 궁금증 ]
1. 접근 지정자에 대한 근본적인 궁금증이 있다. 객체의 필드를 보호하기 위해 변수는 private로 관리하고 public인 getter,setter를 만들었지만
사실 이렇게 구현할 것이었다면 변수를 public으로 해도 된다. 물론 차이가 존재한다는 것은 알고 있다.
getter와 setter를 어떻게 구현하냐에 따라 접근할 수 있는 방법을 제한하고 1차로 filter한다는 것이다.
여기까지는 이해하고 넘어왔는데, 상속 받을 때 접근 지정자를 정의하는 방식을 보고 혼란이 생겼다.
바로 객체의 필드를 대하는 가치관이다. 상속받은 객체에서 접근할 수 있도록 구현해야할 때 선언 접근지정자 + 상속 접근지정자를 적절하게 사용하여 구현해야하는가
아니면 대부분을 private로 설정하고 setter와 getter를 통해 구현해야하는가... 물론 모든 상황에는 각자 어울리는 방법이 있을 것이고,
이것을 담당하는 집단에서의 규칙이 있을 것이다. 그러나 실무에서 보편적으로 추구하는 방법이 궁금하다.

2. 자바에서는 어째서 중복상속을 허용하지 않는가, 좀 더 구체화하자면 자바는 어째서 virtual기능을 제공하지 않는가.
virtual동작방식의 어떠한 단점이 있길래 이를 허용하지 않았는가 궁금하다. 어쩌면 허용하지 않은 것이 아니라 구조적 차이때문에
어쩔 수 없이 안 쓰는 것인가? C++과 자바는 많은 차이가 있다. 바이트코드, JVM, 동적GC 등등... 어떠한 이유인가 궁금하다


